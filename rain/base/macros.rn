# Create separate print statements for each expression
macro print_all(args) as (args)
  save block = ast.block:empty()

  for arg in args:values()
    block:add(ast.rain.print:call([arg]))


# Allow a multiline function call
macro call(expr, argblock) as (fn, args)
  return ast.call:new(fn, args)


# Allow a multiline catching call
macro catchcall(expr, argblock) as (fn, args)
  return ast.catchcall:new(fn, args)


# Destructures a dictionary
macro match(expr, expr) as (lhs, rhs)
  save block = ast.block:empty()

  let value = ast.name:new(gensym())
  block:add(value:_let(rhs))

  for item in lhs.items:values()
    let name = item[0] :: ast.name
    let index = item[1] :: ast.str
    let val = value:idx(index)
    block:add(name:_let(val))


# Creates a switch/case-like control flow
macro case(expr, argblock) as (var, cases)
  save block = ast.block:empty()

  let caseval = ast.name:new(gensym())
  let retval = ast.name:new(gensym())
  block.expr = retval
  block:add(caseval:_let(var))
  block:add(retval:_let(ast._null))

  let cur = null

  for stmt in cases:values()
    continue if stmt.op != "->"
    let cmp = ast._binary:new(caseval, stmt.lhs, "==")
    let ifs = cmp:_if(retval:assn(stmt.rhs), null)

    if stmt.lhs.tag == "name" & stmt.lhs.value == ""
      ifs = ifs.body

    if cur == null
      cur = ifs
      block:add(cur)
    else
      cur.els = ifs
      cur = ifs

  return block
